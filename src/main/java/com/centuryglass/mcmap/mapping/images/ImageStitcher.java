/**
 * @file  ImageStitcher.java
 * 
 * Stitches a set of image tiles together into a single map image, optionally
 * with a Minecraft map item background and border.
 */
package com.centuryglass.mcmap.mapping.images;

import com.centuryglass.mcmap.util.ExtendedValidate;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import javax.imageio.ImageIO;
import org.apache.commons.lang.Validate;

/**
 * Stitches a set of image tiles together into a single map image, optionally
 * with a Minecraft map item background and border.
 */
public class ImageStitcher
{
    /**
     * Read a tile's chunk coordinates from its file name.
     * 
     * @param tile  A map image tile generated by MCMap.
     * 
     * @return      The Minecraft chunk coordinates of that tile's upper left
     *              corner.
     */
    private static Point getTilePos(File tile)
    {
        Validate.notNull(tile, "Map tile file object cannot be null.");
        final String name = tile.getName();
        final String numericChars = "-0123456789";
        int xStart = -1;
        for (int i = 0; i < name.length(); i++)
        {
            if (numericChars.contains(name.substring(i, i + 1)))
            {
                xStart = i;
                break;
            }
        }
        if (xStart < 0)
        {
            return null;
        }
        final int xEnd = name.indexOf(".", xStart);
        final int zStart = xEnd + 1;
        final int zEnd = name.indexOf(".", zStart);
        if (xEnd < 0 || zEnd < 0)
        {
            return null;
        }
        return new Point(Integer.parseInt(name.substring(xStart, xEnd)),
                Integer.parseInt(name.substring(zStart, zEnd)));
    }
    
    /**
     * Stitches a set of tile images together into a single-image map.
     * 
     * @param tileDir         The directory containing tile images to stitch
     *                        together.
     * 
     * @param outFile         The path where the file image will be saved.
     * 
     * @param xMin            The lowest chunk x-coordinate that will be shown
     *                        within the map image.
     * 
     * @param zMin            The lowest chunk z-coordinate that will be shown
     *                        within the map image.
     * 
     * @param width           The height in chunks of the mapped area that will
     *                        be copied into the map image.
     * 
     * @param height          The width in chunks of the mapped area that will
     *                        be copied into the map image.
     * 
     * @param pixelsPerChunk  The width and height in pixels of each chunk drawn
     *                        in the final map image.
     * 
     * @param tileSize        The width and height in chunks of each tile image.
     * 
     * @param drawBackground  Whether the Minecraft map background texture
     *                        should be drawn behind map images.
     */
    public static void stitch(File tileDir,
            File outFile,
            int xMin,
            int zMin,
            int width,
            int height,
            int pixelsPerChunk,
            int tileSize,
            boolean drawBackground)
    {
        ExtendedValidate.isDirectory(tileDir, "Tile source directory");
        ExtendedValidate.couldBeFile(outFile, "Image output path");
        ExtendedValidate.isPositive(width, "Width");
        ExtendedValidate.isPositive(height, "Height");
        ExtendedValidate.isPositive(pixelsPerChunk, "Pixels per chunk");
        ExtendedValidate.isPositive(tileSize, "Tile size");
        
        File [] possibleTiles = tileDir.listFiles();
        Map <File, Point> tilePoints = new HashMap();
        for (File tile : possibleTiles)
        {
            if (tile.isFile() && tile.getPath().endsWith(".png"))
            {
                Point tilePt = getTilePos(tile);
                if (tilePt != null)
                {
                    tilePoints.put(tile, tilePt);
                }
            }
        }
        if (tilePoints.isEmpty())
        {
            return; // No valid files, don't waste time on a blank image.
        }
        
        BufferedImage combinedMap = new BufferedImage(width * pixelsPerChunk,
                height * pixelsPerChunk, BufferedImage.TYPE_INT_ARGB);
        final int xMax = xMin + width;
        final int zMax = zMin + height;
        final int tilePixels = tileSize * pixelsPerChunk;
        Graphics2D mapPainter = combinedMap.createGraphics();
        for (Map.Entry<File, Point> entry : tilePoints.entrySet())
        {
            File tile = entry.getKey();
            Point tilePt = entry.getValue();
            if (tilePt == null)
            {
                continue;
            }
            final int tileXMax = tilePt.x + tileSize;
            final int tileZMax = tilePt.y + tileSize;
            if (tilePt.x >= xMax || tilePt.y >= zMax || tileXMax < xMin 
                    || tileZMax < zMin)
            {
                continue;
            }
            BufferedImage tileImage;
            try
            {
                tileImage = ImageIO.read(tile);
            }
            catch (IOException e)
            {
                System.err.println("Error opening tile " + tile.getName() + ": "
                        + e.getMessage());
                continue;
            }
            mapPainter.drawImage(tileImage,
                    (tilePt.x - xMin) * pixelsPerChunk,
                    (tilePt.y - zMin) * pixelsPerChunk,
                    tilePixels, tilePixels, null);
        }
        // Draw X and Y axis if within the map bounds:
        mapPainter.setColor(new Color(255, 0, 0, 180));
        mapPainter.setStroke(new BasicStroke(pixelsPerChunk * 2));
        if (xMin < 0 && xMax > 0)
        {
            final int xCenter = (0 - xMin) * pixelsPerChunk;
            mapPainter.drawLine(xCenter, 0, xCenter, combinedMap.getHeight());
        }
        if (zMin < 0 && zMax > 0)
        {
            final int zCenter = (0 - zMin) * pixelsPerChunk;
            mapPainter.drawLine(0, zCenter, combinedMap.getWidth(), zCenter);
        }
        if (drawBackground)
        {
            final int largerEdge = Math.max(combinedMap.getWidth(),
                    combinedMap.getHeight());
            final int borderWidth = MapBackground.getBorderWidth(largerEdge);
            final int frameSize = largerEdge + 2 * borderWidth;
            BufferedImage imageFrame = new BufferedImage(frameSize, frameSize,
                    BufferedImage.TYPE_INT_ARGB);
            BufferedImage background = MapBackground.getBackgroundImage();
            Graphics2D framePainter = imageFrame.createGraphics();
            framePainter.drawImage(background, 0, 0, frameSize, frameSize,
                    null);
            framePainter.drawImage(combinedMap,
                    (frameSize - combinedMap.getWidth()) / 2,
                    (frameSize - combinedMap.getHeight()) / 2,
                    combinedMap.getWidth(),
                    combinedMap.getHeight(),
                    null);
            combinedMap = imageFrame;
        }
        try
        {
            ImageIO.write(combinedMap, "png", outFile);
        }
        catch (IOException e)
        {
            System.err.println("Failed to save composite map image to \""
                    + outFile.getPath() + "\"");
        }  
    }
}
